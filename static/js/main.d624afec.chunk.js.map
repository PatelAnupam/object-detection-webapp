{"version":3,"sources":["useWebcam.js","useModel.js","useBoxRenderer.js","index.js","styles.module.css"],"names":["useWebcam","videoRef","_useState","useState","_useState2","Object","slicedToArray","webcamLoaded","setWebcamLoaded","useEffect","navigator","mediaDevices","getUserMedia","audio","video","facingMode","then","stream","current","srcObject","onloadedmetadata","useModel","modelPath","model","setModel","objectDetector","load","getLabelText","prediction","scoreText","score","toFixed","class","renderPredictions","predictions","canvasRef","ctx","getContext","clearRect","canvas","width","height","font","textBaseline","forEach","x","bbox","y","strokeStyle","lineWidth","strokeRect","fillStyle","textWidth","measureText","textHeight","parseInt","fillRect","fillText","detectFrame","_ref","asyncToGenerator","regenerator_default","a","mark","_callee","wrap","_context","prev","next","detect","sent","requestAnimationFrame","stop","_x","_x2","_x3","apply","this","arguments","useBoxRenderer","shouldRender","App","useRef","cameraLoaded","react_default","createElement","Fragment","className","styles","fixed","autoPlay","playsInline","muted","ref","rootElement","document","getElementById","ReactDOM","render","module","exports"],"mappings":"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","file":"static/js/main.d624afec.chunk.js","sourcesContent":["import { useEffect, useState } from 'react'\n\nconst useWebcam = videoRef => {\n  const [webcamLoaded, setWebcamLoaded] = useState(false)\n  useEffect(() => {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      navigator.mediaDevices\n        .getUserMedia({\n          audio: false,\n          video: {\n            facingMode: 'user'\n          }\n        })\n        .then(stream => {\n          // window.stream = stream\n          videoRef.current.srcObject = stream\n          videoRef.current.onloadedmetadata = () => {\n            setWebcamLoaded(true)\n          }\n        })\n    }\n  }, [videoRef])\n  return webcamLoaded\n}\n\nexport default useWebcam\n","import { useEffect, useState } from 'react'\n\nimport objectDetector from '@cloud-annotations/object-detection'\n\nconst useModel = modelPath => {\n  const [model, setModel] = useState()\n  useEffect(() => {\n    objectDetector.load(modelPath).then(model => {\n      setModel(model)\n    })\n  }, [modelPath])\n  return model\n}\n\nexport default useModel\n","import { useEffect } from 'react'\n\nconst SCORE_DIGITS = 4\n\nconst getLabelText = (prediction) => {\n    const scoreText = prediction.score.toFixed(SCORE_DIGITS)\n    return prediction.class + ', score: ' + scoreText\n}\n\nconst renderPredictions = (predictions, canvasRef) => {\n  const ctx = canvasRef.current.getContext('2d')\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n  // Font options.\n  const font = '16px sans-serif'\n  ctx.font = font\n  ctx.textBaseline = 'top'\n  predictions.forEach(prediction => {\n    const x = prediction.bbox[0]\n    const y = prediction.bbox[1]\n    const width = prediction.bbox[2]\n    const height = prediction.bbox[3]\n    // Draw the bounding box.\n    ctx.strokeStyle = '#00FFFF'\n    ctx.lineWidth = 4\n    ctx.strokeRect(x, y, width, height)\n    // Draw the label background.\n    ctx.fillStyle = '#00FFFF'\n    const textWidth = ctx.measureText(getLabelText(prediction)).width\n    const textHeight = parseInt(font, 10) // base 10\n    ctx.fillRect(x, y, textWidth + 4, textHeight + 4)\n  })\n\n  predictions.forEach(prediction => {\n    const x = prediction.bbox[0]\n    const y = prediction.bbox[1]\n    // Draw the text last to ensure it's on top.\n    ctx.fillStyle = '#000000'\n    ctx.fillText(getLabelText(prediction), x, y)\n  })\n}\n\nconst detectFrame = async (model, videoRef, canvasRef) => {\n  const predictions = await model.detect(videoRef.current)\n  renderPredictions(predictions, canvasRef)\n  requestAnimationFrame(() => {\n    detectFrame(model, videoRef, canvasRef)\n  })\n}\n\nconst useBoxRenderer = (model, videoRef, canvasRef, shouldRender) => {\n  useEffect(() => {\n    if (model && shouldRender) {\n      detectFrame(model, videoRef, canvasRef)\n    }\n  }, [canvasRef, model, shouldRender, videoRef])\n}\n\nexport default useBoxRenderer\n","import React, { useRef } from 'react'\nimport ReactDOM from 'react-dom'\n\nimport useWebcam from './useWebcam'\nimport useModel from './useModel'\nimport useBoxRenderer from './useBoxRenderer'\n\nimport styles from './styles.module.css'\n\nconst MODEL_PATH = process.env.PUBLIC_URL + '/model_web'\n\nconst App = () => {\n  const videoRef = useRef()\n  const canvasRef = useRef()\n\n  const cameraLoaded = useWebcam(videoRef)\n  const model = useModel(MODEL_PATH)\n  useBoxRenderer(model, videoRef, canvasRef, cameraLoaded)\n\n  return (\n    <>\n      <video\n        className={styles.fixed}\n        autoPlay\n        playsInline\n        muted\n        ref={videoRef}\n        width=\"600\"\n        height=\"500\"\n      />\n      <canvas\n        className={styles.fixed}\n        ref={canvasRef}\n        width=\"600\"\n        height=\"500\"\n      />\n    </>\n  )\n}\n\nconst rootElement = document.getElementById('root')\nReactDOM.render(<App />, rootElement)\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"fixed\":\"styles_fixed__v-bnh\"};"],"sourceRoot":""}